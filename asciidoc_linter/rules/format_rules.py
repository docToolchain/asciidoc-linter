# format_rules.py - Rules for detecting format issues in AsciiDoc files
"""
Format rules for detecting Markdown syntax and other format issues in AsciiDoc files.
These rules are particularly useful for documents generated by LLMs that may
accidentally use Markdown syntax instead of AsciiDoc.
"""

import re
from typing import List, Union
from .base import Rule, Finding, Severity, Position


class MarkdownSyntaxRule(Rule):
    """
    FMT004: Detect Markdown-style syntax in AsciiDoc files.

    This rule detects common Markdown patterns that LLMs often produce
    when generating AsciiDoc content, and suggests the AsciiDoc equivalent.

    Detected patterns:
    - Markdown headings: # Heading, ## Heading, etc.
    - Markdown links: [text](url)
    - Markdown images: ![alt](path)
    - Markdown code blocks: ```
    - Markdown blockquotes: > text
    """

    id = "FMT004"
    name = "Markdown Syntax Detection"
    description = (
        "Detects Markdown syntax in AsciiDoc files and suggests AsciiDoc alternatives"
    )
    severity = Severity.WARNING

    # Regex patterns for Markdown syntax
    # Markdown heading: # Heading (1-6 hash symbols followed by space and text)
    MARKDOWN_HEADING_PATTERN = re.compile(r"^(#{1,6})\s+(.+)$")

    # Markdown link: [text](url)
    MARKDOWN_LINK_PATTERN = re.compile(r"\[([^\]]+)\]\(([^)]+)\)")

    # Markdown image: ![alt](path)
    MARKDOWN_IMAGE_PATTERN = re.compile(r"!\[([^\]]*)\]\(([^)]+)\)")

    # Markdown code fence: ``` (optionally followed by language)
    MARKDOWN_CODE_FENCE_PATTERN = re.compile(r"^```(\w*)$")

    # Markdown blockquote: > text (at start of line)
    MARKDOWN_BLOCKQUOTE_PATTERN = re.compile(r"^(>+)\s+(.+)$")

    # AsciiDoc block delimiters that indicate code/literal blocks
    ASCIIDOC_CODE_BLOCK_DELIMITERS = {"----", "....", "++++"}

    def __init__(self):
        super().__init__()
        self.enabled = True

    def check(self, document: List[Union[str, object]]) -> List[Finding]:
        """Check the entire document for Markdown syntax."""
        if not self.enabled:
            return []

        findings = []
        in_code_block = False
        current_delimiter = None

        for line_number, line in enumerate(document):
            line_content = self._get_line_content(line)
            stripped = line_content.strip()

            # Check for code block delimiters
            if stripped in self.ASCIIDOC_CODE_BLOCK_DELIMITERS:
                if not in_code_block:
                    in_code_block = True
                    current_delimiter = stripped
                elif stripped == current_delimiter:
                    in_code_block = False
                    current_delimiter = None
                continue

            # Skip content inside code blocks
            if in_code_block:
                continue

            findings.extend(self._check_line(line_content, line_number))
        return findings

    def _get_line_content(self, line: Union[str, object]) -> str:
        """Extract the content from a line object or return the line if it's a string."""
        if hasattr(line, "content"):
            return line.content
        return str(line)

    def _check_line(self, line: str, line_number: int) -> List[Finding]:
        """Check a single line for Markdown syntax patterns."""
        findings = []

        # Skip empty lines
        if not line.strip():
            return findings

        # Skip AsciiDoc comments
        if line.strip().startswith("//"):
            return findings

        # Skip AsciiDoc attributes (lines starting with :)
        if line.strip().startswith(":"):
            return findings

        # Skip AsciiDoc block delimiters
        if line.strip() in ("----", "====", "****", "....", "____", "----"):
            return findings

        # Check for Markdown headings
        findings.extend(self._check_markdown_heading(line, line_number))

        # Check for Markdown images (must be checked before links due to similar syntax)
        findings.extend(self._check_markdown_image(line, line_number))

        # Check for Markdown links
        findings.extend(self._check_markdown_link(line, line_number))

        # Check for Markdown code fences
        findings.extend(self._check_markdown_code_fence(line, line_number))

        # Check for Markdown blockquotes
        findings.extend(self._check_markdown_blockquote(line, line_number))

        return findings

    def _check_markdown_heading(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style headings."""
        findings = []
        match = self.MARKDOWN_HEADING_PATTERN.match(line)

        if match:
            hashes = match.group(1)
            level = len(hashes)
            asciidoc_equivalent = "=" * level

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        f"Markdown heading detected: '{hashes} ' should be "
                        f"'{asciidoc_equivalent} ' in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings

    def _check_markdown_link(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style links."""
        findings = []

        # Skip if line contains AsciiDoc link macro (link:url[text])
        if re.search(r"link:[^\[]+\[", line):
            return findings

        # Find all Markdown links, but exclude image syntax (handled separately)
        # First, temporarily remove image syntax to avoid matching the link part
        line_without_images = re.sub(r"!\[[^\]]*\]\([^)]+\)", "", line)

        for match in self.MARKDOWN_LINK_PATTERN.finditer(line_without_images):
            text = match.group(1)
            url = match.group(2)
            column = match.start() + 1

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1, column=column),
                    message=(
                        f"Markdown link detected: '[{text}]({url})' should be "
                        f"'link:{url}[{text}]' in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings

    def _check_markdown_image(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style images."""
        findings = []

        # Skip if line contains AsciiDoc image macro (image::path[alt] or image:path[alt])
        if re.search(r"image::?[^\[]+\[", line):
            return findings

        for match in self.MARKDOWN_IMAGE_PATTERN.finditer(line):
            alt = match.group(1)
            path = match.group(2)
            column = match.start() + 1

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1, column=column),
                    message=(
                        f"Markdown image detected: '![{alt}]({path})' should be "
                        f"'image::{path}[{alt}]' in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings

    def _check_markdown_code_fence(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style code fences."""
        findings = []
        match = self.MARKDOWN_CODE_FENCE_PATTERN.match(line.strip())

        if match:
            language = match.group(1)
            if language:
                suggestion = f"'[source,{language}]' followed by '----'"
            else:
                suggestion = "'----' (listing block)"

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        f"Markdown code fence detected: '```{language}' should be "
                        f"{suggestion} in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings

    def _check_markdown_blockquote(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style blockquotes."""
        findings = []
        match = self.MARKDOWN_BLOCKQUOTE_PATTERN.match(line)

        if match:
            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        "Markdown blockquote detected: '> text' should be "
                        "'[quote]' block or '____' delimiter in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings


class ExplicitNumberedListRule(Rule):
    """
    FMT001: Detect explicit numbered lists in AsciiDoc files.

    This rule detects lines starting with explicit numbers (1., 2., 3., etc.)
    instead of the AsciiDoc auto-numbering dot syntax (.).

    LLMs often generate explicit numbered lists which:
    - Don't auto-renumber when items are added/removed
    - Are not semantic AsciiDoc
    - Create maintenance burden
    """

    id = "FMT001"
    name = "Explicit Numbered List Detection"
    description = (
        "Detects explicit numbered lists (1., 2., etc.) and suggests "
        "using AsciiDoc dot-syntax (.) instead"
    )
    severity = Severity.WARNING

    # Regex pattern for explicit numbered list: starts with number, dot, space
    EXPLICIT_NUMBERED_LIST_PATTERN = re.compile(r"^(\d+)\.\s+(.+)$")

    # AsciiDoc block delimiters that indicate code/literal blocks
    ASCIIDOC_CODE_BLOCK_DELIMITERS = {"----", "....", "++++"}

    def __init__(self):
        super().__init__()
        self.enabled = True

    def check(self, document: List[Union[str, object]]) -> List[Finding]:
        """Check the entire document for explicit numbered lists."""
        if not self.enabled:
            return []

        findings = []
        in_code_block = False
        current_delimiter = None

        for line_number, line in enumerate(document):
            line_content = self._get_line_content(line)
            stripped = line_content.strip()

            # Check for code block delimiters
            if stripped in self.ASCIIDOC_CODE_BLOCK_DELIMITERS:
                if not in_code_block:
                    in_code_block = True
                    current_delimiter = stripped
                elif stripped == current_delimiter:
                    in_code_block = False
                    current_delimiter = None
                continue

            # Skip content inside code blocks
            if in_code_block:
                continue

            findings.extend(self._check_line(line_content, line_number))

        return findings

    def _get_line_content(self, line: Union[str, object]) -> str:
        """Extract the content from a line object or return the line if it's a string."""
        if hasattr(line, "content"):
            return line.content
        return str(line)

    def _check_line(self, line: str, line_number: int) -> List[Finding]:
        """Check a single line for explicit numbered list pattern."""
        findings = []

        # Skip empty lines
        if not line.strip():
            return findings

        # Skip AsciiDoc comments
        if line.strip().startswith("//"):
            return findings

        match = self.EXPLICIT_NUMBERED_LIST_PATTERN.match(line)

        if match:
            number = match.group(1)
            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        f"Explicit numbered list detected: '{number}. ' should be "
                        f"'. ' (AsciiDoc auto-numbered list syntax)"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings
