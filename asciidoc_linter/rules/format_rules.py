# format_rules.py - Rules for detecting format issues in AsciiDoc files
"""
Format rules for detecting Markdown syntax and other format issues in AsciiDoc files.
These rules are particularly useful for documents generated by LLMs that may
accidentally use Markdown syntax instead of AsciiDoc.
"""

import re
from typing import List, Union
from .base import Rule, Finding, Severity, Position


class MarkdownSyntaxRule(Rule):
    """
    FMT004: Detect Markdown-style syntax in AsciiDoc files.

    This rule detects common Markdown patterns that LLMs often produce
    when generating AsciiDoc content, and suggests the AsciiDoc equivalent.

    Detected patterns:
    - Markdown headings: # Heading, ## Heading, etc.
    - Markdown links: [text](url)
    - Markdown images: ![alt](path)
    - Markdown code blocks: ```
    - Markdown blockquotes: > text
    """

    id = "FMT004"
    name = "Markdown Syntax Detection"
    description = (
        "Detects Markdown syntax in AsciiDoc files and suggests AsciiDoc alternatives"
    )
    severity = Severity.WARNING

    # Regex patterns for Markdown syntax
    # Markdown heading: # Heading (1-6 hash symbols followed by space and text)
    MARKDOWN_HEADING_PATTERN = re.compile(r"^(#{1,6})\s+(.+)$")

    # Markdown link: [text](url)
    MARKDOWN_LINK_PATTERN = re.compile(r"\[([^\]]+)\]\(([^)]+)\)")

    # Markdown image: ![alt](path)
    MARKDOWN_IMAGE_PATTERN = re.compile(r"!\[([^\]]*)\]\(([^)]+)\)")

    # Markdown code fence: ``` (optionally followed by language)
    MARKDOWN_CODE_FENCE_PATTERN = re.compile(r"^```(\w*)$")

    # Markdown blockquote: > text (at start of line)
    MARKDOWN_BLOCKQUOTE_PATTERN = re.compile(r"^(>+)\s+(.+)$")

    # AsciiDoc block delimiters that indicate code/literal blocks
    ASCIIDOC_CODE_BLOCK_DELIMITERS = {"----", "....", "++++"}

    def __init__(self):
        super().__init__()
        self.enabled = True

    def check(self, document: List[Union[str, object]]) -> List[Finding]:
        """Check the entire document for Markdown syntax."""
        if not self.enabled:
            return []

        findings = []
        in_code_block = False
        current_delimiter = None

        for line_number, line in enumerate(document):
            line_content = self._get_line_content(line)
            stripped = line_content.strip()

            # Check for code block delimiters
            if stripped in self.ASCIIDOC_CODE_BLOCK_DELIMITERS:
                if not in_code_block:
                    in_code_block = True
                    current_delimiter = stripped
                elif stripped == current_delimiter:
                    in_code_block = False
                    current_delimiter = None
                continue

            # Skip content inside code blocks
            if in_code_block:
                continue

            findings.extend(self._check_line(line_content, line_number))
        return findings

    def _get_line_content(self, line: Union[str, object]) -> str:
        """Extract the content from a line object or return the line if it's a string."""
        if hasattr(line, "content"):
            return line.content
        return str(line)

    def _check_line(self, line: str, line_number: int) -> List[Finding]:
        """Check a single line for Markdown syntax patterns."""
        findings = []

        # Skip empty lines
        if not line.strip():
            return findings

        # Skip AsciiDoc comments
        if line.strip().startswith("//"):
            return findings

        # Skip AsciiDoc attributes (lines starting with :)
        if line.strip().startswith(":"):
            return findings

        # Skip AsciiDoc block delimiters
        if line.strip() in ("----", "====", "****", "....", "____", "----"):
            return findings

        # Check for Markdown headings
        findings.extend(self._check_markdown_heading(line, line_number))

        # Check for Markdown images (must be checked before links due to similar syntax)
        findings.extend(self._check_markdown_image(line, line_number))

        # Check for Markdown links
        findings.extend(self._check_markdown_link(line, line_number))

        # Check for Markdown code fences
        findings.extend(self._check_markdown_code_fence(line, line_number))

        # Check for Markdown blockquotes
        findings.extend(self._check_markdown_blockquote(line, line_number))

        return findings

    def _check_markdown_heading(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style headings."""
        findings = []
        match = self.MARKDOWN_HEADING_PATTERN.match(line)

        if match:
            hashes = match.group(1)
            level = len(hashes)
            asciidoc_equivalent = "=" * level

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        f"Markdown heading detected: '{hashes} ' should be "
                        f"'{asciidoc_equivalent} ' in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings

    def _check_markdown_link(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style links."""
        findings = []

        # Skip if line contains AsciiDoc link macro (link:url[text])
        if re.search(r"link:[^\[]+\[", line):
            return findings

        # Find all Markdown links, but exclude image syntax (handled separately)
        # First, temporarily remove image syntax to avoid matching the link part
        line_without_images = re.sub(r"!\[[^\]]*\]\([^)]+\)", "", line)

        for match in self.MARKDOWN_LINK_PATTERN.finditer(line_without_images):
            text = match.group(1)
            url = match.group(2)
            column = match.start() + 1

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1, column=column),
                    message=(
                        f"Markdown link detected: '[{text}]({url})' should be "
                        f"'link:{url}[{text}]' in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings

    def _check_markdown_image(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style images."""
        findings = []

        # Skip if line contains AsciiDoc image macro (image::path[alt] or image:path[alt])
        if re.search(r"image::?[^\[]+\[", line):
            return findings

        for match in self.MARKDOWN_IMAGE_PATTERN.finditer(line):
            alt = match.group(1)
            path = match.group(2)
            column = match.start() + 1

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1, column=column),
                    message=(
                        f"Markdown image detected: '![{alt}]({path})' should be "
                        f"'image::{path}[{alt}]' in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings

    def _check_markdown_code_fence(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style code fences."""
        findings = []
        match = self.MARKDOWN_CODE_FENCE_PATTERN.match(line.strip())

        if match:
            language = match.group(1)
            if language:
                suggestion = f"'[source,{language}]' followed by '----'"
            else:
                suggestion = "'----' (listing block)"

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        f"Markdown code fence detected: '```{language}' should be "
                        f"{suggestion} in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings

    def _check_markdown_blockquote(self, line: str, line_number: int) -> List[Finding]:
        """Check for Markdown-style blockquotes."""
        findings = []
        match = self.MARKDOWN_BLOCKQUOTE_PATTERN.match(line)

        if match:
            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        "Markdown blockquote detected: '> text' should be "
                        "'[quote]' block or '____' delimiter in AsciiDoc"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings


class ExplicitNumberedListRule(Rule):
    """
    FMT001: Detect explicit numbered lists in AsciiDoc files.

    This rule detects lines starting with explicit numbers (1., 2., 3., etc.)
    instead of the AsciiDoc auto-numbering dot syntax (.).

    LLMs often generate explicit numbered lists which:
    - Don't auto-renumber when items are added/removed
    - Are not semantic AsciiDoc
    - Create maintenance burden
    """

    id = "FMT001"
    name = "Explicit Numbered List Detection"
    description = (
        "Detects explicit numbered lists (1., 2., etc.) and suggests "
        "using AsciiDoc dot-syntax (.) instead"
    )
    severity = Severity.WARNING

    # Regex pattern for explicit numbered list: starts with number, dot, space
    EXPLICIT_NUMBERED_LIST_PATTERN = re.compile(r"^(\d+)\.\s+(.+)$")

    # AsciiDoc block delimiters that indicate code/literal blocks
    ASCIIDOC_CODE_BLOCK_DELIMITERS = {"----", "....", "++++"}

    def __init__(self):
        super().__init__()
        self.enabled = True

    def check(self, document: List[Union[str, object]]) -> List[Finding]:
        """Check the entire document for explicit numbered lists."""
        if not self.enabled:
            return []

        findings = []
        in_code_block = False
        current_delimiter = None

        for line_number, line in enumerate(document):
            line_content = self._get_line_content(line)
            stripped = line_content.strip()

            # Check for code block delimiters
            if stripped in self.ASCIIDOC_CODE_BLOCK_DELIMITERS:
                if not in_code_block:
                    in_code_block = True
                    current_delimiter = stripped
                elif stripped == current_delimiter:
                    in_code_block = False
                    current_delimiter = None
                continue

            # Skip content inside code blocks
            if in_code_block:
                continue

            findings.extend(self._check_line(line_content, line_number))

        return findings

    def _get_line_content(self, line: Union[str, object]) -> str:
        """Extract the content from a line object or return the line if it's a string."""
        if hasattr(line, "content"):
            return line.content
        return str(line)

    def _check_line(self, line: str, line_number: int) -> List[Finding]:
        """Check a single line for explicit numbered list pattern."""
        findings = []

        # Skip empty lines
        if not line.strip():
            return findings

        # Skip AsciiDoc comments
        if line.strip().startswith("//"):
            return findings

        match = self.EXPLICIT_NUMBERED_LIST_PATTERN.match(line)

        if match:
            number = match.group(1)
            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        f"Explicit numbered list detected: '{number}. ' should be "
                        f"'. ' (AsciiDoc auto-numbered list syntax)"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings


class NonSemanticDefinitionListRule(Rule):
    """
    FMT002: Detect non-semantic definition list patterns in AsciiDoc files.

    This rule detects common patterns that LLMs use to create "fake" definition
    lists instead of proper AsciiDoc Definition List syntax (Term:: Definition).

    Detected patterns:
    - *Term*: definition (single asterisk bold)
    - **Term**: definition (double asterisk bold)
    - - *Term*: definition (list item with bold term)
    - * *Term*: definition (list item with bold term)
    """

    id = "FMT002"
    name = "Non-Semantic Definition List Detection"
    description = (
        "Detects non-semantic definition list patterns and suggests "
        "using AsciiDoc 'Term:: Definition' syntax"
    )
    severity = Severity.WARNING

    # Regex patterns for non-semantic definition lists
    # Pattern 1: *Term*: at start of line (single asterisk)
    SINGLE_BOLD_TERM_PATTERN = re.compile(r"^\*([^*]+)\*:\s+")

    # Pattern 2: **Term**: at start of line (double asterisk)
    DOUBLE_BOLD_TERM_PATTERN = re.compile(r"^\*\*([^*]+)\*\*:\s+")

    # Pattern 3: - *Term*: (list item with bold term, single asterisk)
    LIST_SINGLE_BOLD_PATTERN = re.compile(r"^-\s+\*([^*]+)\*:\s+")

    # Pattern 4: * *Term*: (asterisk list item with bold term)
    ASTERISK_LIST_BOLD_PATTERN = re.compile(r"^\*\s+\*([^*]+)\*:\s+")

    # AsciiDoc block delimiters that indicate code/literal blocks
    ASCIIDOC_CODE_BLOCK_DELIMITERS = {"----", "....", "++++"}

    def __init__(self):
        super().__init__()
        self.enabled = True

    def check(self, document: List[Union[str, object]]) -> List[Finding]:
        """Check the entire document for non-semantic definition list patterns."""
        if not self.enabled:
            return []

        findings = []
        in_code_block = False
        current_delimiter = None

        for line_number, line in enumerate(document):
            line_content = self._get_line_content(line)
            stripped = line_content.strip()

            # Check for code block delimiters
            if stripped in self.ASCIIDOC_CODE_BLOCK_DELIMITERS:
                if not in_code_block:
                    in_code_block = True
                    current_delimiter = stripped
                elif stripped == current_delimiter:
                    in_code_block = False
                    current_delimiter = None
                continue

            # Skip content inside code blocks
            if in_code_block:
                continue

            findings.extend(self._check_line(line_content, line_number))

        return findings

    def _get_line_content(self, line: Union[str, object]) -> str:
        """Extract the content from a line object or return the line if it's a string."""
        if hasattr(line, "content"):
            return line.content
        return str(line)

    def _check_line(self, line: str, line_number: int) -> List[Finding]:
        """Check a single line for non-semantic definition list patterns."""
        findings = []

        # Skip empty lines
        if not line.strip():
            return findings

        # Skip AsciiDoc comments
        if line.strip().startswith("//"):
            return findings

        # Skip AsciiDoc attributes (lines starting with :)
        if line.strip().startswith(":"):
            return findings

        # Skip proper AsciiDoc definition lists (Term::)
        if "::" in line and not line.strip().startswith("*"):
            return findings

        # Check for single bold term pattern: *Term*:
        match = self.SINGLE_BOLD_TERM_PATTERN.match(line)
        if match:
            term = match.group(1)
            findings.append(self._create_finding(term, line, line_number))
            return findings  # Only report one finding per line

        # Check for double bold term pattern: **Term**:
        match = self.DOUBLE_BOLD_TERM_PATTERN.match(line)
        if match:
            term = match.group(1)
            findings.append(self._create_finding(term, line, line_number))
            return findings

        # Check for list item with single bold: - *Term*:
        match = self.LIST_SINGLE_BOLD_PATTERN.match(line)
        if match:
            term = match.group(1)
            findings.append(self._create_finding(term, line, line_number))
            return findings

        # Check for asterisk list with bold: * *Term*:
        match = self.ASTERISK_LIST_BOLD_PATTERN.match(line)
        if match:
            term = match.group(1)
            findings.append(self._create_finding(term, line, line_number))
            return findings

        return findings

    def _create_finding(self, term: str, line: str, line_number: int) -> Finding:
        """Create a finding for a non-semantic definition list pattern."""
        return Finding(
            rule_id=self.id,
            position=Position(line=line_number + 1),
            message=(
                f"Non-semantic definition list detected: use '{term}:: ' "
                f"(AsciiDoc definition list syntax) instead"
            ),
            severity=self.severity,
            context=line,
        )


class CounterInTitleRule(Rule):
    """
    FMT003: Detect counter syntax in section titles.

    This rule detects {counter:name} usage in section titles, which is often
    unnecessary or misused by LLMs trying to create numbered sections.

    Problems with counter in titles:
    - Simple sequential sections don't need explicit counters
    - Counter state can be confusing across includes
    - Often mimics numbered headings from other formats unnecessarily
    """

    id = "FMT003"
    name = "Counter Syntax in Title Detection"
    description = (
        "Detects {counter:...} usage in section titles and suggests "
        "reviewing if counters are really needed"
    )
    severity = Severity.WARNING

    # Regex pattern for counter in section title
    # Matches lines starting with = followed by {counter:name} or {counter2:name}
    COUNTER_IN_TITLE_PATTERN = re.compile(r"^(=+)\s+.*\{counter2?:([^}]+)\}")

    # AsciiDoc block delimiters that indicate code/literal blocks
    ASCIIDOC_CODE_BLOCK_DELIMITERS = {"----", "....", "++++"}

    def __init__(self):
        super().__init__()
        self.enabled = True

    def check(self, document: List[Union[str, object]]) -> List[Finding]:
        """Check the entire document for counter syntax in section titles."""
        if not self.enabled:
            return []

        findings = []
        in_code_block = False
        current_delimiter = None

        for line_number, line in enumerate(document):
            line_content = self._get_line_content(line)
            stripped = line_content.strip()

            # Check for code block delimiters
            if stripped in self.ASCIIDOC_CODE_BLOCK_DELIMITERS:
                if not in_code_block:
                    in_code_block = True
                    current_delimiter = stripped
                elif stripped == current_delimiter:
                    in_code_block = False
                    current_delimiter = None
                continue

            # Skip content inside code blocks
            if in_code_block:
                continue

            findings.extend(self._check_line(line_content, line_number))

        return findings

    def _get_line_content(self, line: Union[str, object]) -> str:
        """Extract the content from a line object or return the line if it's a string."""
        if hasattr(line, "content"):
            return line.content
        return str(line)

    def _check_line(self, line: str, line_number: int) -> List[Finding]:
        """Check a single line for counter syntax in section title."""
        findings = []

        # Skip empty lines
        if not line.strip():
            return findings

        # Only check lines that start with = (section titles)
        if not line.strip().startswith("="):
            return findings

        match = self.COUNTER_IN_TITLE_PATTERN.match(line)

        if match:
            counter_name = match.group(2)
            # Remove format specifier if present (e.g., "step:%02d" -> "step")
            if ":" in counter_name:
                counter_name = counter_name.split(":")[0]

            findings.append(
                Finding(
                    rule_id=self.id,
                    position=Position(line=line_number + 1),
                    message=(
                        f"Counter syntax in section title detected: '{{counter:{counter_name}}}'. "
                        f"Consider using explicit numbering or descriptive titles instead"
                    ),
                    severity=self.severity,
                    context=line,
                )
            )

        return findings
