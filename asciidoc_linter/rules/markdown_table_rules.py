# markdown_table_rules.py - Rule for detecting Markdown table syntax
"""
Rule for detecting Markdown table syntax in AsciiDoc files.
This is particularly useful for documents generated by LLMs that may
accidentally use Markdown table syntax instead of AsciiDoc tables.
"""

import re
from typing import List, Union
from .base import Rule, Finding, Severity, Position


class MarkdownTableRule(Rule):
    """
    FMT005: Detect Markdown table syntax in AsciiDoc files.

    This rule detects Markdown table syntax which commonly appears when
    documentation is AI-generated or when contributors are more familiar
    with Markdown. Markdown tables break AsciiDoc rendering.

    Detected patterns:
    - Table separator rows: |---|---| or |:---|:---:| etc.
    - Table data/header rows adjacent to a separator (start and end with |)
    """

    id = "FMT005"
    name = "Markdown Table Syntax Detection"
    description = (
        "Detects Markdown table syntax and suggests using "
        "AsciiDoc table syntax (|===) instead"
    )
    severity = Severity.ERROR

    # Markdown table separator: |---| with optional colons for alignment
    SEPARATOR_PATTERN = re.compile(r"^\s*\|[\s:]*-{2,}[\s:]*[-|\s:]*$")

    # Markdown table row: starts and ends with | (with content between)
    TABLE_ROW_PATTERN = re.compile(r"^\s*\|.+\|\s*$")

    # AsciiDoc table delimiter
    ASCIIDOC_TABLE_DELIMITER = re.compile(r"^\s*\|===\s*$")

    # AsciiDoc block delimiters that indicate code/literal blocks
    ASCIIDOC_CODE_BLOCK_DELIMITERS = {"----", "....", "++++"}

    def __init__(self):
        super().__init__()
        self.enabled = True

    def check(self, document: List[Union[str, object]]) -> List[Finding]:
        """Check the entire document for Markdown table syntax."""
        if not self.enabled:
            return []

        lines, skip_lines = self._preprocess(document)
        return self._find_markdown_tables(lines, skip_lines)

    def _preprocess(self, document):
        """Extract lines and determine which to skip (code blocks, tables)."""
        lines = []
        in_code_block = False
        current_delimiter = None
        in_asciidoc_table = False
        skip_lines = set()

        for i, line in enumerate(document):
            line_content = self._get_line_content(line)
            lines.append(line_content)
            stripped = line_content.strip()

            if stripped in self.ASCIIDOC_CODE_BLOCK_DELIMITERS:
                if not in_code_block:
                    in_code_block = True
                    current_delimiter = stripped
                elif stripped == current_delimiter:
                    in_code_block = False
                    current_delimiter = None
                skip_lines.add(i)
                continue

            if in_code_block:
                skip_lines.add(i)
                continue

            if self.ASCIIDOC_TABLE_DELIMITER.match(line_content):
                in_asciidoc_table = not in_asciidoc_table
                skip_lines.add(i)
                continue

            if in_asciidoc_table:
                skip_lines.add(i)

        return lines, skip_lines

    def _find_markdown_tables(self, lines, skip_lines):
        """Find separator lines and expand to adjacent table rows."""
        findings = []
        flagged_lines = set()

        for i, line_content in enumerate(lines):
            if i in skip_lines:
                continue
            if self.SEPARATOR_PATTERN.match(line_content):
                flagged_lines.add(i)
                findings.append(
                    Finding(
                        rule_id=self.id,
                        position=Position(line=i + 1),
                        message=(
                            "Markdown table separator detected. "
                            "Use AsciiDoc table syntax (|===) instead"
                        ),
                        severity=self.severity,
                        context=line_content,
                    )
                )

                # Expand upward to find adjacent table rows
                j = i - 1
                while j >= 0 and j not in skip_lines:
                    if self.TABLE_ROW_PATTERN.match(lines[j]):
                        flagged_lines.add(j)
                    else:
                        break
                    j -= 1

                # Expand downward to find adjacent table rows
                j = i + 1
                while j < len(lines) and j not in skip_lines:
                    if self.TABLE_ROW_PATTERN.match(lines[j]):
                        flagged_lines.add(j)
                    else:
                        break
                    j += 1

        # Add findings for adjacent data rows
        for i in sorted(flagged_lines):
            if not self.SEPARATOR_PATTERN.match(lines[i]):
                findings.append(
                    Finding(
                        rule_id=self.id,
                        position=Position(line=i + 1),
                        message=(
                            "Markdown table row detected. "
                            "Use AsciiDoc table syntax (|===) instead"
                        ),
                        severity=self.severity,
                        context=lines[i],
                    )
                )

        return findings

    def _get_line_content(self, line: Union[str, object]) -> str:
        """Extract content from a line object or return the string."""
        if hasattr(line, "content"):
            return line.content
        return str(line)
