var documents = [

{
    "id": 0,
    "uri": "arc42/01_introduction_and_goals.html",
    "menu": "arc42",
    "title": "Introduction and Goals",
    "text": " Table of Contents Introduction and Goals Requirements Overview Quality Goals Stakeholders Introduction and Goals Requirements Overview The AsciiDoc Linter is a tool designed to ensure consistent formatting and structure in AsciiDoc documents. It helps teams maintain high-quality documentation by enforcing style rules and best practices. Key requirements include: Validate AsciiDoc heading structure Ensure consistent formatting Provide clear error messages Easy integration into existing workflows Extensible rule system Quality Goals Priority Quality Goal Motivation 1 Extensibility The system must be easily extensible with new rules to accommodate different documentation standards and requirements. 2 Reliability The linter must provide consistent and accurate results to maintain user trust. 3 Usability Error messages must be clear and actionable, helping users fix documentation issues efficiently. 4 Performance The linter should process documents quickly to maintain a smooth workflow. 5 Maintainability The code must be well-structured and documented to facilitate future enhancements. Stakeholders Role/Name Contact Expectations Documentation Writers various * Clear error messages * Consistent results * Quick feedback Documentation Maintainers various * Configurable rules * Reliable validation * Integration with existing tools Development Team dev team * Extensible architecture * Good test coverage * Clear documentation Technical Writers various * Support for AsciiDoc best practices * Customizable rule sets * Batch processing capabilities "
},

{
    "id": 1,
    "uri": "readme/README.html",
    "menu": "readme",
    "title": "README.adoc",
    "text": " Table of Contents AsciiDoc Linter About Features Implemented Rules Planned Rules Installation Usage Basic Usage Output Formats Example Output Development Running Tests Project Structure Contributing Development Guidelines License Acknowledgments Roadmap Contact AsciiDoc Linter A Python-based linter for AsciiDoc files that helps maintain consistent documentation quality and style. Part of the docToolchain project. About AsciiDoc Linter is a command-line tool that checks your AsciiDoc files for common issues and style violations. It helps maintain consistent documentation by enforcing rules for heading structure, formatting, whitespace, and image usage. This project is part of docToolchain ( https://doctoolchain.org ), a collection of documentation tools and best practices. Features Implemented Rules Rule ID Description Severity HEAD001 Check for proper heading hierarchy (no skipping levels) ERROR HEAD002 Verify heading format (spacing and capitalization) ERROR/WARNING HEAD003 Detect multiple top-level headers ERROR BLOCK001 Check for unterminated blocks (listing, example, sidebar, etc.) ERROR BLOCK002 Verify proper spacing around blocks WARNING WS001 Check whitespace usage (blank lines, list markers, tabs) WARNING IMG001 Verify image attributes and file references WARNING/ERROR Planned Rules TABLE001: Table formatting consistency LINK001: Broken internal references FMT001: Markdown-compatible styles detection Installation # Clone the repository git clone https://github.com/docToolchain/asciidoc-linter.git # Navigate to the project directory cd asciidoc-linter # Install the package pip install . Usage Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Check with specific output format asciidoc-lint --format json document.adoc Output Formats The linter supports three output formats: console (default): Human-readable output json : Machine-readable JSON format html : HTML report format Example Output Checking file: document.adoc ERROR: Heading level skipped: found h3 after h1 (line 15) === Advanced Topics WARNING: Heading should start with uppercase letter (line 23) == introduction to concepts ERROR: Unterminated listing block starting (line 45) ---- WARNING: Block should be preceded by a blank line (line 67) ---- ERROR: Multiple top-level headings found (line 30) First heading at line 1: 'Document Title' WARNING: Missing alt text for image: diagram.png (line 80) image::diagram.png[] Development Running Tests # Run all tests python run_tests.py # Run specific test file python -m unittest tests/rules/test_heading_rules.py Project Structure asciidoc-linter/ ‚îú‚îÄ‚îÄ asciidoc_linter/ ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îú‚îÄ‚îÄ cli.py ‚îÇ ‚îú‚îÄ‚îÄ rules/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ base.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ heading_rules.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ block_rules.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ whitespace_rules.py ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ image_rules.py ‚îÇ ‚îú‚îÄ‚îÄ parser.py ‚îÇ ‚îî‚îÄ‚îÄ reporter.py ‚îú‚îÄ‚îÄ tests/ ‚îÇ ‚îî‚îÄ‚îÄ rules/ ‚îÇ ‚îú‚îÄ‚îÄ test_heading_rules.py ‚îÇ ‚îú‚îÄ‚îÄ test_block_rules.py ‚îÇ ‚îú‚îÄ‚îÄ test_whitespace_rules.py ‚îÇ ‚îî‚îÄ‚îÄ test_image_rules.py ‚îú‚îÄ‚îÄ docs/ ‚îÇ ‚îú‚îÄ‚îÄ requirements.adoc ‚îÇ ‚îî‚îÄ‚îÄ block_rules.adoc ‚îú‚îÄ‚îÄ README.adoc ‚îî‚îÄ‚îÄ run_tests.py Contributing Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change. Development Guidelines Write tests for new rules Update documentation Follow Python code style guidelines Add appropriate error messages and context License This project is licensed under the MIT License - see the LICENSE file for details. Acknowledgments Part of the docToolchain project ( https://doctoolchain.org ) Inspired by various linting tools and the need for better AsciiDoc quality control Thanks to the AsciiDoc community for their excellent documentation and tools Roadmap Phase 1 (Current) ‚úÖ Basic heading rules ‚úÖ Block structure rules ‚úÖ Whitespace rules ‚úÖ Image validation ‚è≥ Configuration system Phase 2 üî≤ Table validation üî≤ Link checking üî≤ Format rules Phase 3 üî≤ IDE integration üî≤ Git pre-commit hooks üî≤ Custom rule development Contact Project Homepage: https://github.com/docToolchain/asciidoc-linter Issue Tracker: https://github.com/docToolchain/asciidoc-linter/issues docToolchain Homepage: https://doctoolchain.org "
},

{
    "id": 2,
    "uri": "arc42/08_concepts.html",
    "menu": "arc42",
    "title": "Cross-cutting Concepts",
    "text": " Table of Contents Cross-cutting Concepts Domain Concepts Security Concepts Development Concepts Configuration Concepts Cross-cutting Concepts Domain Concepts Security Concepts Authentication and Authorization Package distribution secured via PyPI authentication Configuration files with restricted access Signed releases with GPG keys Input Validation Strict content validation Safe file handling Memory usage limits Output Sanitization Escaped error messages Safe file paths handling Controlled error reporting Development Concepts Test Strategy Release Process Configuration Concepts Rule Configuration rules: heading_hierarchy: enabled: true severity: error options: max_level: 6 heading_format: enabled: true severity: warning options: require_space: true require_capitalization: true Plugin System "
},

{
    "id": 3,
    "uri": "arc42/11_technical_risks.html",
    "menu": "arc42",
    "title": "Technical Risks and Technical Debt",
    "text": " Table of Contents Technical Risks and Technical Debt Risk Analysis Technical Debt Risk Matrix Technical Risks and Technical Debt Risk Analysis Risk Description Impact Probability Mitigation Performance Degradation Rule processing becomes slow with many rules High Medium * Profile rule execution * Implement rule caching * Optimize core algorithms Memory Leaks Long-running processes accumulate memory High Low * Regular memory profiling * Automated testing * Resource cleanup False Positives Rules report incorrect violations Medium High * Extensive test cases * User feedback system * Rule configuration options Plugin Conflicts Custom rules interfere with core rules Medium Medium * Plugin isolation * Version compatibility checks * Clear plugin API Technical Debt Current Technical Debt Area Description Impact Priority Test Coverage Some edge cases not covered Medium High Documentation Some advanced features poorly documented Medium Medium Error Handling Some error cases not specifically handled High High Configuration Hard-coded values that should be configurable Low Low Planned Improvements Risk Matrix "
},

{
    "id": 4,
    "uri": "arc42/07_deployment_view.html",
    "menu": "arc42",
    "title": "Deployment View",
    "text": " Table of Contents Deployment View Infrastructure Level 1 Technical Infrastructure Security and Access Deployment View Infrastructure Level 1 Technical Infrastructure Security and Access "
},

{
    "id": 5,
    "uri": "arc42/05_building_block_view.html",
    "menu": "arc42",
    "title": "Building Block View",
    "text": " Table of Contents Building Block View Level 1 - System Overview Level 2 - Core Components Level 3 - Rule Implementation Building Block View Level 1 - System Overview Level 2 - Core Components Level 3 - Rule Implementation "
},

{
    "id": 6,
    "uri": "arc42/10_quality_requirements.html",
    "menu": "arc42",
    "title": "Quality Requirements",
    "text": " Table of Contents Quality Requirements Quality Scenarios Quality Tree Quality Requirements Quality Scenarios Performance Scenarios Scenario Stimulus Response Priority Fast Document Processing Process 1000-line document Complete in &lt; 1 second High Multiple File Processing Process 100 documents Complete in &lt; 10 seconds Medium Memory Usage Process large document (10MB) Use &lt; 100MB RAM High Startup Time Launch linter Ready in &lt; 0.5 seconds Medium Reliability Scenarios Scenario Stimulus Response Priority Error Recovery Invalid input file Clear error message, continue with next file High Configuration Error Invalid rule configuration Detailed error message, use defaults High Plugin Failure Plugin crashes Isolate failure, continue with other rules Medium Resource Exhaustion System low on memory Graceful shutdown, save progress Medium Usability Scenarios Scenario Stimulus Response Priority Clear Error Messages Rule violation found Show file, line, and actionable message High Configuration Change rule settings Take effect without restart Medium Integration Use in CI pipeline Exit code reflects success/failure High Documentation Look up rule details Find explanation within 30 seconds Medium Quality Tree "
},

{
    "id": 7,
    "uri": "arc42/index.html",
    "menu": "arc42",
    "title": "AsciiDoc Linter Architecture Documentation",
    "text": " Table of Contents AsciiDoc Linter Architecture Documentation Introduction and Goals Requirements Overview Quality Goals Stakeholders Architecture Constraints Technical Constraints Organizational Constraints Conventions System Scope and Context Business Context Technical Context Solution Strategy Quality Goals and Architectural Approaches Technology Decisions Implementation Patterns Building Block View Level 1 - System Overview Level 2 - Core Components Level 3 - Rule Implementation Runtime View Document Processing Sequence Rule Loading Sequence Error Reporting Sequence Deployment View Infrastructure Level 1 Technical Infrastructure Security and Access Cross-cutting Concepts Domain Concepts Security Concepts Authentication and Authorization Input Validation Output Sanitization Development Concepts Test Strategy Release Process Configuration Concepts Rule Configuration Plugin System Architecture Decisions ADR 1: Rule Base Class Design Status Context Decision Consequences ADR 2: Finding Data Structure Status Context Decision Consequences ADR 3: Rule Implementation Strategy Status Context Decision Consequences ADR 4: Test Strategy Status Context Decision Consequences Quality Requirements Quality Scenarios Performance Scenarios Reliability Scenarios Usability Scenarios Quality Tree Technical Risks and Technical Debt Risk Analysis Technical Debt Current Technical Debt Planned Improvements Risk Matrix Glossary AsciiDoc Linter Architecture Documentation Introduction and Goals Requirements Overview The AsciiDoc Linter is a tool designed to ensure consistent formatting and structure in AsciiDoc documents. It helps teams maintain high-quality documentation by enforcing style rules and best practices. Key requirements include: Validate AsciiDoc heading structure Ensure consistent formatting Provide clear error messages Easy integration into existing workflows Extensible rule system Quality Goals Priority Quality Goal Motivation 1 Extensibility The system must be easily extensible with new rules to accommodate different documentation standards and requirements. 2 Reliability The linter must provide consistent and accurate results to maintain user trust. 3 Usability Error messages must be clear and actionable, helping users fix documentation issues efficiently. 4 Performance The linter should process documents quickly to maintain a smooth workflow. 5 Maintainability The code must be well-structured and documented to facilitate future enhancements. Stakeholders Role/Name Contact Expectations Documentation Writers various * Clear error messages * Consistent results * Quick feedback Documentation Maintainers various * Configurable rules * Reliable validation * Integration with existing tools Development Team dev team * Extensible architecture * Good test coverage * Clear documentation Technical Writers various * Support for AsciiDoc best practices * Customizable rule sets * Batch processing capabilities Architecture Constraints Technical Constraints Constraint Description Background Python 3.8+ The system must run on Python 3.8 or higher Need for modern language features and type hints Platform Independence Must run on Windows, Linux, and macOS Support for all major development platforms No External Dependencies Core functionality should work without external libraries Easy installation and deployment Memory Footprint Should process documents with minimal memory usage Support for large documentation projects Organizational Constraints Constraint Description Background Open Source Project must be open source under MIT license Community involvement and transparency Documentation All code must be documented with docstrings Maintainability and community contribution Test Coverage Minimum 90% test coverage required Quality assurance and reliability Version Control Git-based development with feature branches Collaborative development process Conventions Convention Description Background Code Style Follow PEP 8 guidelines Python community standards Type Hints Use type hints throughout the code Code clarity and IDE support Commit Messages Follow conventional commits specification Clear change history Documentation Format Use AsciiDoc for all documentation Dogfooding our own tool System Scope and Context Business Context Technical Context Solution Strategy Quality Goals and Architectural Approaches Quality Goal Solution Approach Details Extensibility * Abstract base classes * Plugin architecture * Clear interfaces * New rules can be added by extending base classes * Plugin system allows external rule packages * Well-defined interfaces for rule implementation Reliability * Comprehensive testing * Strong typing * Defensive programming * High test coverage * Type hints throughout the code * Careful input validation Usability * Clear error messages * Context information * Configuration options * Detailed error descriptions * Line and column information * Configurable rule severity Performance * Efficient algorithms * Lazy loading * Caching * Line-by-line processing * Rules loaded on demand * Cache parsing results Maintainability * Clean architecture * SOLID principles * Documentation * Clear separation of concerns * Single responsibility principle * Comprehensive documentation Technology Decisions Technology Decision Rationale Python Primary implementation language * Strong standard library * Great text processing capabilities * Wide adoption in tooling Regular Expressions Pattern matching * Built into Python * Efficient for text processing * Well understood by developers YAML Configuration format * Human readable * Standard format * Good library support unittest Testing framework * Part of Python standard library * Well known to developers * Good IDE support Implementation Patterns Building Block View Level 1 - System Overview Level 2 - Core Components Level 3 - Rule Implementation Runtime View Document Processing Sequence Rule Loading Sequence Error Reporting Sequence Deployment View Infrastructure Level 1 Technical Infrastructure Security and Access Cross-cutting Concepts Domain Concepts Security Concepts Authentication and Authorization Package distribution secured via PyPI authentication Configuration files with restricted access Signed releases with GPG keys Input Validation Strict content validation Safe file handling Memory usage limits Output Sanitization Escaped error messages Safe file paths handling Controlled error reporting Development Concepts Test Strategy Release Process Configuration Concepts Rule Configuration rules: heading_hierarchy: enabled: true severity: error options: max_level: 6 heading_format: enabled: true severity: warning options: require_space: true require_capitalization: true Plugin System Architecture Decisions ADR 1: Rule Base Class Design Status Accepted Context We need a flexible and extensible way to implement different linting rules for AsciiDoc documents. Decision We will use an abstract base class Rule with a defined interface that all concrete rules must implement. Consequences Positive Consistent interface for all rules Easy to add new rules Clear separation of concerns Simplified testing through common interface Negative Additional abstraction layer Slight performance overhead ADR 2: Finding Data Structure Status Accepted Context Rule violations need to be reported in a consistent and informative way. Decision We will use a Finding data class with fields for message, severity, position, rule ID, and context. Consequences Positive Structured error reporting Rich context for violations Consistent error format Negative More complex than simple string messages Requires more memory for storing findings ADR 3: Rule Implementation Strategy Status Accepted Context Rules need to process AsciiDoc content and identify violations efficiently. Decision Each rule will process the content line by line, using regular expressions for pattern matching. Consequences Positive Simple implementation Good performance for most cases Easy to understand and maintain Negative Limited context awareness May miss some complex patterns Regular expressions can become complex ADR 4: Test Strategy Status Accepted Context Rules need to be thoroughly tested to ensure reliable operation. Decision Each rule will have its own test class with multiple test methods covering various scenarios. Consequences Positive High test coverage Clear test organization Easy to add new test cases Negative More maintenance effort Longer test execution time :jbake-status: published :jbake-order: 10 :jbake-type: page_toc :jbake-menu: arc42 :jbake-title: Quality Requirements Quality Requirements Quality Scenarios Performance Scenarios Scenario Stimulus Response Priority Fast Document Processing Process 1000-line document Complete in &lt; 1 second High Multiple File Processing Process 100 documents Complete in &lt; 10 seconds Medium Memory Usage Process large document (10MB) Use &lt; 100MB RAM High Startup Time Launch linter Ready in &lt; 0.5 seconds Medium Reliability Scenarios Scenario Stimulus Response Priority Error Recovery Invalid input file Clear error message, continue with next file High Configuration Error Invalid rule configuration Detailed error message, use defaults High Plugin Failure Plugin crashes Isolate failure, continue with other rules Medium Resource Exhaustion System low on memory Graceful shutdown, save progress Medium Usability Scenarios Scenario Stimulus Response Priority Clear Error Messages Rule violation found Show file, line, and actionable message High Configuration Change rule settings Take effect without restart Medium Integration Use in CI pipeline Exit code reflects success/failure High Documentation Look up rule details Find explanation within 30 seconds Medium Quality Tree Technical Risks and Technical Debt Risk Analysis Risk Description Impact Probability Mitigation Performance Degradation Rule processing becomes slow with many rules High Medium * Profile rule execution * Implement rule caching * Optimize core algorithms Memory Leaks Long-running processes accumulate memory High Low * Regular memory profiling * Automated testing * Resource cleanup False Positives Rules report incorrect violations Medium High * Extensive test cases * User feedback system * Rule configuration options Plugin Conflicts Custom rules interfere with core rules Medium Medium * Plugin isolation * Version compatibility checks * Clear plugin API Technical Debt Current Technical Debt Area Description Impact Priority Test Coverage Some edge cases not covered Medium High Documentation Some advanced features poorly documented Medium Medium Error Handling Some error cases not specifically handled High High Configuration Hard-coded values that should be configurable Low Low Planned Improvements Risk Matrix Glossary Term Definition Additional Information AsciiDoc Lightweight markup language for documentation Similar to Markdown, but with more features for technical documentation Linter Tool that analyzes source code or text for potential errors Focuses on style, format, and structure issues Rule Individual check that validates specific aspects Can be enabled/disabled and configured Finding Result of a rule check indicating a potential issue Contains message, severity, and location information Severity Importance level of a finding ERROR, WARNING, or INFO Position Location in a document where an issue was found Contains line and optional column information Plugin Extension that adds additional functionality Can provide custom rules and configurations CI/CD Continuous Integration/Continuous Deployment Automated build, test, and deployment process PyPI Python Package Index Central repository for Python packages Virtual Environment Isolated Python runtime environment Manages project-specific dependencies Type Hints Python type annotations Helps with code understanding and static analysis Unit Test Test of individual components Ensures correct behavior of specific functions Integration Test Test of component interactions Verifies system behavior as a whole Coverage Measure of code tested by automated tests Usually expressed as percentage Technical Debt Development shortcuts that need future attention Balance between quick delivery and maintainability "
},

{
    "id": 8,
    "uri": "arc42/04_solution_strategy.html",
    "menu": "arc42",
    "title": "Solution Strategy",
    "text": " Table of Contents Solution Strategy Quality Goals and Architectural Approaches Technology Decisions Implementation Patterns Solution Strategy Quality Goals and Architectural Approaches Quality Goal Solution Approach Details Extensibility * Abstract base classes * Plugin architecture * Clear interfaces * New rules can be added by extending base classes * Plugin system allows external rule packages * Well-defined interfaces for rule implementation Reliability * Comprehensive testing * Strong typing * Defensive programming * High test coverage * Type hints throughout the code * Careful input validation Usability * Clear error messages * Context information * Configuration options * Detailed error descriptions * Line and column information * Configurable rule severity Performance * Efficient algorithms * Lazy loading * Caching * Line-by-line processing * Rules loaded on demand * Cache parsing results Maintainability * Clean architecture * SOLID principles * Documentation * Clear separation of concerns * Single responsibility principle * Comprehensive documentation Technology Decisions Technology Decision Rationale Python Primary implementation language * Strong standard library * Great text processing capabilities * Wide adoption in tooling Regular Expressions Pattern matching * Built into Python * Efficient for text processing * Well understood by developers YAML Configuration format * Human readable * Standard format * Good library support unittest Testing framework * Part of Python standard library * Well known to developers * Good IDE support Implementation Patterns "
},

{
    "id": 9,
    "uri": "arc42/03_system_scope_and_context.html",
    "menu": "arc42",
    "title": "System Scope and Context",
    "text": " Table of Contents System Scope and Context Business Context Technical Context System Scope and Context Business Context Technical Context "
},

{
    "id": 10,
    "uri": "arc42/12_glossary.html",
    "menu": "arc42",
    "title": "Glossary",
    "text": " Table of Contents Glossary Glossary Term Definition Additional Information AsciiDoc Lightweight markup language for documentation Similar to Markdown, but with more features for technical documentation Linter Tool that analyzes source code or text for potential errors Focuses on style, format, and structure issues Rule Individual check that validates specific aspects Can be enabled/disabled and configured Finding Result of a rule check indicating a potential issue Contains message, severity, and location information Severity Importance level of a finding ERROR, WARNING, or INFO Position Location in a document where an issue was found Contains line and optional column information Plugin Extension that adds additional functionality Can provide custom rules and configurations CI/CD Continuous Integration/Continuous Deployment Automated build, test, and deployment process PyPI Python Package Index Central repository for Python packages Virtual Environment Isolated Python runtime environment Manages project-specific dependencies Type Hints Python type annotations Helps with code understanding and static analysis Unit Test Test of individual components Ensures correct behavior of specific functions Integration Test Test of component interactions Verifies system behavior as a whole Coverage Measure of code tested by automated tests Usually expressed as percentage Technical Debt Development shortcuts that need future attention Balance between quick delivery and maintainability "
},

{
    "id": 11,
    "uri": "arc42/09_architecture_decisions.html",
    "menu": "arc42",
    "title": "Architecture Decisions",
    "text": " Table of Contents Architecture Decisions ADR 1: Rule Base Class Design ADR 2: Finding Data Structure ADR 3: Rule Implementation Strategy ADR 4: Test Strategy Architecture Decisions ADR 1: Rule Base Class Design Status Accepted Context We need a flexible and extensible way to implement different linting rules for AsciiDoc documents. Decision We will use an abstract base class Rule with a defined interface that all concrete rules must implement. Consequences Positive Consistent interface for all rules Easy to add new rules Clear separation of concerns Simplified testing through common interface Negative Additional abstraction layer Slight performance overhead ADR 2: Finding Data Structure Status Accepted Context Rule violations need to be reported in a consistent and informative way. Decision We will use a Finding data class with fields for message, severity, position, rule ID, and context. Consequences Positive Structured error reporting Rich context for violations Consistent error format Negative More complex than simple string messages Requires more memory for storing findings ADR 3: Rule Implementation Strategy Status Accepted Context Rules need to process AsciiDoc content and identify violations efficiently. Decision Each rule will process the content line by line, using regular expressions for pattern matching. Consequences Positive Simple implementation Good performance for most cases Easy to understand and maintain Negative Limited context awareness May miss some complex patterns Regular expressions can become complex ADR 4: Test Strategy Status Accepted Context Rules need to be thoroughly tested to ensure reliable operation. Decision Each rule will have its own test class with multiple test methods covering various scenarios. Consequences Positive High test coverage Clear test organization Easy to add new test cases Negative More maintenance effort Longer test execution time "
},

{
    "id": 12,
    "uri": "arc42/02_architecture_constraints.html",
    "menu": "arc42",
    "title": "Architecture Constraints",
    "text": " Table of Contents Architecture Constraints Technical Constraints Organizational Constraints Conventions Architecture Constraints Technical Constraints Constraint Description Background Python 3.8+ The system must run on Python 3.8 or higher Need for modern language features and type hints Platform Independence Must run on Windows, Linux, and macOS Support for all major development platforms No External Dependencies Core functionality should work without external libraries Easy installation and deployment Memory Footprint Should process documents with minimal memory usage Support for large documentation projects Organizational Constraints Constraint Description Background Open Source Project must be open source under MIT license Community involvement and transparency Documentation All code must be documented with docstrings Maintainability and community contribution Test Coverage Minimum 90% test coverage required Quality assurance and reliability Version Control Git-based development with feature branches Collaborative development process Conventions Convention Description Background Code Style Follow PEP 8 guidelines Python community standards Type Hints Use type hints throughout the code Code clarity and IDE support Commit Messages Follow conventional commits specification Clear change history Documentation Format Use AsciiDoc for all documentation Dogfooding our own tool "
},

{
    "id": 13,
    "uri": "arc42/06_runtime_view.html",
    "menu": "arc42",
    "title": "Runtime View",
    "text": " Table of Contents Runtime View Document Processing Sequence Rule Loading Sequence Error Reporting Sequence Runtime View Document Processing Sequence Rule Loading Sequence Error Reporting Sequence "
},

{
    "id": 14,
    "uri": "canvas/architecture-canvas.html",
    "menu": "canvas",
    "title": "Architecture Communication Canvas: AsciiDoc Linter",
    "text": " Table of Contents Architecture Communication Canvas: AsciiDoc Linter Architecture Communication Canvas: AsciiDoc Linter .canvas tr:nth-child(1) td:nth-child(1), .canvas tr:nth-child(1) td:nth-child(2), .canvas tr:nth-child(2) td:nth-child(1), .canvas tr:nth-child(3) td:nth-child(1), .canvas tr:nth-child(4) td:nth-child(1) { background-color: #8fe4b4; border: 1px solid black; } .canvas tr:nth-child(1) td:nth-child(3), .canvas tr:nth-child(1) td:nth-child(4), .canvas tr:nth-child(4) td:nth-child(2) { background-color: #94d7ef; border: 1px solid black; } .canvas tr:nth-child(5) td:nth-child(1) { background-color: #ffc7c6; border: 1px solid black; } Value Proposition Automated quality assurance for AsciiDoc documentation Consistent documentation style across projects Early detection of documentation issues Reduced review effort Integration with CI/CD pipelines Core Functions Lint AsciiDoc files for common issues Check heading structure and format Validate document consistency Generate detailed reports Configurable rule sets Multiple output formats (console, JSON, HTML) Git pre-commit hook integration Core Decisions - Good or Bad Good: Python as implementation language (wide adoption, great libraries) Modular rule system for easy extension Clear separation of concerns (rules, parser, reporter) Test-driven development approach AsciiDoc for documentation Bad: Limited to AsciiDoc format No real-time linting No IDE integration yet Strategic: Focus on documentation quality Extensible architecture Community-driven rule development Technologies Python 3.8+ unittest framework AsciiDoc parser YAML/JSON for configuration Git integration CI/CD tools HTML report generation Key Stakeholder Documentation writers Technical authors Development teams Documentation maintainers Open source projects Technical documentation teams Quality assurance teams Quality Requirements Performance: Fast processing for CI/CD Extensibility: Easy to add new rules Reliability: No false positives Usability: Clear error messages Configurability: Flexible rule settings Maintainability: Well-documented code Testability: Comprehensive test suite Business Context External Systems: Version Control Systems (Git) CI/CD Pipelines Documentation Build Tools IDE Plugins (planned) Issue Tracking Systems Data Flow: AsciiDoc files as input Configuration files (YAML/JSON) Lint reports as output Integration webhooks Components / Modules Core Risks and Missing Information Risks: Performance impact on large documentation sets False positives affecting user acceptance Complexity of rule configurations Integration challenges with existing tools Maintenance of rule set as AsciiDoc evolves Missing Information: Real-world usage patterns Common documentation anti-patterns IDE integration requirements Performance benchmarks User preferences for rule configuration Software Architecture Canvas by Gernot Starke, Patrick Roos and arc42 Contributors is licensed under Attribution-ShareAlike 4.0 International "
},

{
    "id": 15,
    "uri": "manual/testing.html",
    "menu": "manual",
    "title": "Testing Guide",
    "text": " Table of Contents Testing Guide Overview Running Tests Test Structure Writing Tests Test Data Continuous Integration Testing Guide Overview The AsciiDoc Linter uses Python&#8217;s unittest framework for testing. Tests are organized by rule type and functionality. Running Tests Running All Tests # From project root python run_tests.py # With coverage report coverage run -m unittest discover coverage report Running Specific Tests # Run tests for heading rules python -m unittest tests/rules/test_heading_rules.py # Run a specific test class python -m unittest tests.rules.test_heading_rules.TestHeadingFormatRule # Run a specific test method python -m unittest tests.rules.test_heading_rules.TestHeadingFormatRule.test_valid_format Test Structure Test Organization tests/ ‚îú‚îÄ‚îÄ __init__.py ‚îú‚îÄ‚îÄ rules/ ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îú‚îÄ‚îÄ test_heading_rules.py ‚îÇ ‚îî‚îÄ‚îÄ test_block_rules.py ‚îú‚îÄ‚îÄ test_cli.py ‚îî‚îÄ‚îÄ test_parser.py Test Classes Each rule has its own test class: class TestHeadingFormatRule(unittest.TestCase): def setUp(self): self.rule = HeadingFormatRule() def test_valid_format(self): content = \"\"\" = Valid Heading == Another Valid \"\"\" findings = self.rule.check(content) self.assertEqual(len(findings), 0) Writing Tests Test Guidelines Test both valid and invalid cases Include edge cases Test error messages Test severity levels Test rule configurations Example Test Pattern Arrange: Set up test data Act: Execute the code Assert: Verify results def test_invalid_format(self): # Arrange content = \"=invalid heading\" # Act findings = self.rule.check(content) # Assert self.assertEqual(len(findings), 2) self.assertEqual(findings[0].severity, Severity.ERROR) Test Data Sample Documents Create realistic test documents Cover various scenarios Include complex cases Document test case purpose Test Fixtures Use setUp and tearDown Share common test data Clean up after tests Continuous Integration GitHub Actions name: Tests on: [push, pull_request] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Run Tests run: python run_tests.py Coverage Requirements Aim for 90%+ coverage Cover all code paths Include error conditions Test edge cases "
},

{
    "id": 16,
    "uri": "manual/development.html",
    "menu": "manual",
    "title": "Development Guide",
    "text": " Table of Contents Development Guide Setting Up Development Environment Project Structure Current Implementation Status Adding New Rules Code Style Testing Pull Request Process Release Process Getting Help Development Guide Setting Up Development Environment Clone the Repository git clone https://github.com/docToolchain/asciidoc-linter.git cd asciidoc-linter Create Virtual Environment python -m venv venv source venv/bin/activate # On Windows: venv\\Scripts\\activate pip install -e . Project Structure asciidoc-linter/ ‚îú‚îÄ‚îÄ asciidoc_linter/ # Main package ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îú‚îÄ‚îÄ cli.py # Command line interface ‚îÇ ‚îú‚îÄ‚îÄ rules/ # Rule implementations ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ base.py # Base classes for rules ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ heading_rules.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ block_rules.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ whitespace_rules.py ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ image_rules.py ‚îÇ ‚îú‚îÄ‚îÄ parser.py # AsciiDoc parser ‚îÇ ‚îî‚îÄ‚îÄ reporter.py # Output formatters ‚îú‚îÄ‚îÄ tests/ # Test files ‚îÇ ‚îî‚îÄ‚îÄ rules/ # Rule-specific tests ‚îú‚îÄ‚îÄ docs/ # Documentation ‚îî‚îÄ‚îÄ README.adoc Current Implementation Status Implemented Features Core rule engine with base classes Rule implementations: Heading rules (hierarchy, format, multiple top-level) Block rules (termination, spacing) Whitespace rules (spacing, formatting) Image rules (attributes, file verification) Basic command line interface Multiple output formats (console, JSON, HTML) Comprehensive test suite Planned Features Configuration system (YAML/JSON) Rule enabling/disabling Severity customization Custom rule parameters Additional rule types IDE integration Git hooks Adding New Rules Rule Implementation Steps Create a new rule class: from .base import Rule, Finding, Severity, Position class MyNewRule(Rule): \"\"\" RULE_ID: Short description. Detailed explanation of what the rule checks. \"\"\" def __init__(self): super().__init__() self.id = \"RULE_ID\" @property def description(self) -&gt; str: return \"Description of what this rule checks\" def check(self, content: str) -&gt; List[Finding]: findings = [] # Implementation here return findings Add tests for the rule: class TestMyNewRule(unittest.TestCase): def setUp(self): self.rule = MyNewRule() def test_valid_case(self): content = \"Valid content\" findings = self.rule.check(content) self.assertEqual(len(findings), 0) def test_invalid_case(self): content = \"Invalid content\" findings = self.rule.check(content) self.assertEqual(len(findings), 1) self.assertEqual(findings[0].rule_id, \"RULE_ID\") Register the rule in the linter Update documentation Rule Guidelines Clear rule IDs and descriptions Meaningful error messages Proper severity levels Contextual information in findings Comprehensive test cases Documentation with examples Code Style Python Guidelines Follow PEP 8 Use type hints Write docstrings (Google style) Keep functions focused and testable Maximum line length: 100 characters Use meaningful variable names Documentation Guidelines Use AsciiDoc format Include examples for all features Explain error messages Document configuration options Keep README.adoc up to date Testing Running Tests # Run all tests python run_tests.py # Run specific test file python -m unittest tests/rules/test_heading_rules.py # Run specific test case python -m unittest tests.rules.test_heading_rules.TestHeadingHierarchyRule Test Guidelines Write tests for all new features Include both positive and negative test cases Test edge cases Maintain high test coverage Use meaningful test names Pull Request Process Create feature branch Implement changes Add/update tests Update documentation Run full test suite Submit PR Release Process Update version number in init .py Update changelog Run full test suite Create release notes Tag release Build and publish Getting Help GitHub Issues: https://github.com/docToolchain/asciidoc-linter/issues Project Wiki: https://github.com/docToolchain/asciidoc-linter/wiki docToolchain Community: https://doctoolchain.org/community "
},

{
    "id": 17,
    "uri": "manual/usage.html",
    "menu": "manual",
    "title": "Usage Guide",
    "text": " Table of Contents Usage Guide Command Line Interface Configuration Output Formats Integration Best Practices Troubleshooting Usage Guide Command Line Interface Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Check with specific output format asciidoc-lint --format json document.adoc # Use specific configuration asciidoc-lint --config my-config.yml document.adoc Command Line Options Option Default Description --format console Output format (console, json, html) --config None Path to configuration file --verbose False Enable verbose output --quiet False Suppress non-error output Configuration Configuration File # .asciidoc-lint.yml rules: HEAD001: enabled: true severity: error HEAD002: enabled: true severity: warning Rule Configuration Enable/disable rules Set severity levels Configure rule-specific options Set file patterns Output Formats Console Output document.adoc:15 ERROR: Heading level skipped document.adoc:23 WARNING: Heading should start with uppercase JSON Output { \"findings\": [ { \"rule\": \"HEAD001\", \"severity\": \"error\", \"message\": \"Heading level skipped\", \"line\": 15 } ] } HTML Report Generates a detailed HTML report with: Summary statistics Detailed findings Source context Rule explanations Integration Git Pre-commit Hook #!/bin/sh files=$(git diff --cached --name-only --diff-filter=ACM | grep '.adoc$') if [ -n \"$files\" ]; then asciidoc-lint $files fi CI/CD Integration GitHub Actions Example name: Lint AsciiDoc on: [push, pull_request] jobs: lint: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Lint Documentation run: | pip install asciidoc-linter asciidoc-lint docs/ Best Practices Document Organization Use consistent heading levels Add blank lines around blocks Use proper formatting Include alt text for images Error Resolution Table 1. Common Issues and Solutions Issue Solution Skipped heading level Ensure heading levels increment by one Missing space after = Add space after heading markers Multiple top-level headings Use only one level-1 heading per document Troubleshooting Common Problems Configuration file not found Rule conflicts Performance issues False positives Debug Mode # Enable debug output asciidoc-lint --debug document.adoc # Show rule processing details asciidoc-lint --verbose document.adoc "
},

{
    "id": 18,
    "uri": "manual/rules.html",
    "menu": "manual",
    "title": "AsciiDoc Linter Rules",
    "text": " Table of Contents AsciiDoc Linter Rules Heading Rules Block Rules AsciiDoc Linter Rules Heading Rules HEAD001: Heading Hierarchy Ensures proper heading level incrementation (no skipped levels). Description This rule checks that heading levels are not skipped. For example, you cannot go from a level 1 heading (=) directly to a level 3 heading (===) without having a level 2 heading (==) in between. Examples Valid Heading Hierarchy == Document Title (Level 1) === Section (Level 2) ==== Subsection (Level 3) === Another Section (Level 2) Invalid Heading Hierarchy == Document Title (Level 1) ==== Subsection (Level 3) // Error: Skipped Level 2 HEAD002: Heading Format Ensures proper heading format (spacing and capitalization). Description This rule checks two aspects of heading format: 1. There must be a space after the = characters 2. The heading text should start with an uppercase letter Examples Valid Heading Format == Document Title === Section Title ==== Subsection Title Invalid Heading Format =Document Title // Error: No space after = === section title // Warning: Starts with lowercase HEAD003: Multiple Top Level Headings Ensures document has only one top-level heading. Description This rule checks that there is only one level 1 heading (=) in the document. Multiple top-level headings can indicate structural problems or accidentally split documents. Examples Valid Single Top Level == Main Document Title === Section One === Section Two Invalid Multiple Top Level == First Title === Section One == Second Title // Error: Multiple top-level headings Block Rules BLOCK001: Unterminated Blocks Checks for blocks that are not properly terminated. Description This rule ensures that all block delimiters are properly paired. Each opening delimiter must have a matching closing delimiter. Supported Block Types Listing blocks (----) Example blocks (====) Sidebar blocks ( * *) Literal blocks (&#8230;&#8203;.) Quote blocks ( __ ) Table blocks (|===) Comment blocks (////) Passthrough blocks (). Examples Valid Block Termination [source,python] def hello(): print(\"Hello, World!\") .Example Block ==== Some example content ==== Invalid Block Termination [source,python] def hello(): print(\"Hello, World!\") Example 1. Example Block Some example content ==== BLOCK002: Block Spacing Verifies proper spacing around blocks. ===== Description This rule checks that blocks are properly separated from surrounding content with blank lines, improving readability. ===== Examples .Valid Block Spacing [source,asciidoc] Some text before the block. Block content Some text after the block. .Invalid Block Spacing [source,asciidoc] Some text before the block. ---- // Warning: No blank line before block Block content Some text after the block. // Warning: No blank line after block === Whitespace Rules ==== WS001: Whitespace Usage Ensures proper whitespace usage throughout the document. ===== Checks Performed Consecutive Empty Lines : No more than one consecutive empty line List Marker Spacing : Proper space after list markers (*, -, .) Admonition Block Spacing : Blank line before admonition blocks Trailing Whitespace : No trailing spaces at end of lines Tab Usage : No tabs (use spaces instead) Section Title Spacing : Blank lines around section titles ===== Examples Valid Whitespace Usage == Document Title === Section Title * List item 1 * List item 2 NOTE: This is a note. Some text here. Invalid Whitespace Usage == Document Title === Section Title // Missing blank line before *Invalid list item // Missing space after marker NOTE: Invalid note // Missing blank line before Some text here // Trailing spaces Tabbed line // Tab instead of spaces Extra blank line // Too many blank lines === Image Rules ==== IMG001: Image Attributes Verifies image attributes and file references. ===== Description This rule checks: 1. All images have alt text 2. Referenced local images exist 3. Block images have titles 4. Image attributes are properly formatted ===== Examples Valid Image Usage // Inline image with alt text image:icon.png[Icon] // Block image with title and alt text .Figure 1: System Architecture image::diagram.png[Architecture Diagram] // External image with alt text image:https://example.com/img.png[Example Image] Invalid Image Usage // Missing alt text image:icon.png[] // Missing title for block image image::diagram.png[Diagram] // Non-existent local file image::missing.png[Missing Image] === Planned Rules ==== TABLE001: Table Formatting (Planned) Will check table formatting consistency: * Column alignment * Header row presence * Cell content formatting ==== LINK001: Link Verification (Planned) Will verify: * Internal cross-references * External link validity * Anchor definitions ==== FMT001: Format Consistency (Planned) Will check: * Consistent emphasis style * List formatting * Admonition usage "
},

{
    "id": 19,
    "uri": "manual/introduction.html",
    "menu": "manual",
    "title": "Introduction",
    "text": " Table of Contents Introduction About the Project Key Features Project Goals Technical Overview Getting Started Current Status Introduction About the Project AsciiDoc Linter is a Python-based tool designed to help maintain high-quality AsciiDoc documentation. It checks your AsciiDoc files for common issues and style violations, helping teams maintain consistent documentation standards. As part of the docToolchain project ( https://doctoolchain.org ), it integrates well with existing documentation workflows. Key Features Heading structure validation Proper hierarchy (no skipped levels) Consistent formatting Single top-level heading Block validation Proper block termination Consistent spacing Whitespace consistency Line spacing List formatting Tab detection Image validation Attribute checking File existence verification Multiple output formats (console, JSON, HTML) Project Goals Improve documentation quality through automated checks Enforce consistent styling across documentation Reduce manual review effort Catch common mistakes early in the documentation process Support documentation as code practices Integrate with existing documentation toolchains Technical Overview Table 1. Technology Stack Component Description Language Python 3.8+ Testing unittest framework Documentation AsciiDoc Configuration YAML/JSON (planned) Getting Started Prerequisites Python 3.8 or higher Git (for installation) Installation Note Direct installation via pip is planned for future releases. Currently, installation is done via git clone. # Clone the repository git clone https://github.com/docToolchain/asciidoc-linter.git # Navigate to the project directory cd asciidoc-linter # Install the package pip install . Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Get help asciidoc-lint --help Current Status Implemented Features Core linting engine Basic rule set (headings, blocks, whitespace, images) Command-line interface Multiple output formats Planned Features Configuration system (YAML/JSON) Additional rule sets (tables, links, cross-references) Direct installation via pip IDE integration Git pre-commit hooks "
},

{
    "id": 20,
    "uri": "manual/index.html",
    "menu": "manual",
    "title": "AsciiDoc Linter Manual",
    "text": " Table of Contents AsciiDoc Linter Manual Introduction Development Guide Testing Guide Usage Guide AsciiDoc Linter Rules AsciiDoc Linter Manual Introduction About the Project AsciiDoc Linter is a Python-based tool designed to help maintain high-quality AsciiDoc documentation. It checks your AsciiDoc files for common issues and style violations, helping teams maintain consistent documentation standards. As part of the docToolchain project ( https://doctoolchain.org ), it integrates well with existing documentation workflows. Key Features Heading structure validation Proper hierarchy (no skipped levels) Consistent formatting Single top-level heading Block validation Proper block termination Consistent spacing Whitespace consistency Line spacing List formatting Tab detection Image validation Attribute checking File existence verification Multiple output formats (console, JSON, HTML) Project Goals Improve documentation quality through automated checks Enforce consistent styling across documentation Reduce manual review effort Catch common mistakes early in the documentation process Support documentation as code practices Integrate with existing documentation toolchains Technical Overview Table 1. Technology Stack Component Description Language Python 3.8+ Testing unittest framework Documentation AsciiDoc Configuration YAML/JSON (planned) Getting Started Prerequisites Python 3.8 or higher Git (for installation) Installation Direct installation via pip is planned for future releases. Currently, installation is done via git clone. # Clone the repository git clone https://github.com/docToolchain/asciidoc-linter.git # Navigate to the project directory cd asciidoc-linter # Install the package pip install . Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Get help asciidoc-lint --help Current Status Implemented Features Core linting engine Basic rule set (headings, blocks, whitespace, images) Command-line interface Multiple output formats Planned Features Configuration system (YAML/JSON) Additional rule sets (tables, links, cross-references) Direct installation via pip IDE integration Git pre-commit hooks Development Guide Setting Up Development Environment Clone the Repository git clone https://github.com/docToolchain/asciidoc-linter.git cd asciidoc-linter Create Virtual Environment python -m venv venv source venv/bin/activate # On Windows: venv\\Scripts\\activate pip install -e . Project Structure asciidoc-linter/ ‚îú‚îÄ‚îÄ asciidoc_linter/ # Main package ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îú‚îÄ‚îÄ cli.py # Command line interface ‚îÇ ‚îú‚îÄ‚îÄ rules/ # Rule implementations ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ base.py # Base classes for rules ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ heading_rules.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ block_rules.py ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ whitespace_rules.py ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ image_rules.py ‚îÇ ‚îú‚îÄ‚îÄ parser.py # AsciiDoc parser ‚îÇ ‚îî‚îÄ‚îÄ reporter.py # Output formatters ‚îú‚îÄ‚îÄ tests/ # Test files ‚îÇ ‚îî‚îÄ‚îÄ rules/ # Rule-specific tests ‚îú‚îÄ‚îÄ docs/ # Documentation ‚îî‚îÄ‚îÄ README.adoc Current Implementation Status Implemented Features Core rule engine with base classes Rule implementations: Heading rules (hierarchy, format, multiple top-level) Block rules (termination, spacing) Whitespace rules (spacing, formatting) Image rules (attributes, file verification) Basic command line interface Multiple output formats (console, JSON, HTML) Comprehensive test suite Planned Features Configuration system (YAML/JSON) Rule enabling/disabling Severity customization Custom rule parameters Additional rule types IDE integration Git hooks Adding New Rules Rule Implementation Steps Create a new rule class: from .base import Rule, Finding, Severity, Position class MyNewRule(Rule): \"\"\" RULE_ID: Short description. Detailed explanation of what the rule checks. \"\"\" def __init__(self): super().__init__() self.id = \"RULE_ID\" @property def description(self) -&gt; str: return \"Description of what this rule checks\" def check(self, content: str) -&gt; List[Finding]: findings = [] # Implementation here return findings Add tests for the rule: class TestMyNewRule(unittest.TestCase): def setUp(self): self.rule = MyNewRule() def test_valid_case(self): content = \"Valid content\" findings = self.rule.check(content) self.assertEqual(len(findings), 0) def test_invalid_case(self): content = \"Invalid content\" findings = self.rule.check(content) self.assertEqual(len(findings), 1) self.assertEqual(findings[0].rule_id, \"RULE_ID\") Register the rule in the linter Update documentation Rule Guidelines Clear rule IDs and descriptions Meaningful error messages Proper severity levels Contextual information in findings Comprehensive test cases Documentation with examples Code Style Python Guidelines Follow PEP 8 Use type hints Write docstrings (Google style) Keep functions focused and testable Maximum line length: 100 characters Use meaningful variable names Documentation Guidelines Use AsciiDoc format Include examples for all features Explain error messages Document configuration options Keep README.adoc up to date Testing Running Tests # Run all tests python run_tests.py # Run specific test file python -m unittest tests/rules/test_heading_rules.py # Run specific test case python -m unittest tests.rules.test_heading_rules.TestHeadingHierarchyRule Test Guidelines Write tests for all new features Include both positive and negative test cases Test edge cases Maintain high test coverage Use meaningful test names Pull Request Process Create feature branch Implement changes Add/update tests Update documentation Run full test suite Submit PR Release Process Update version number in init .py Update changelog Run full test suite Create release notes Tag release Build and publish Getting Help GitHub Issues: https://github.com/docToolchain/asciidoc-linter/issues Project Wiki: https://github.com/docToolchain/asciidoc-linter/wiki docToolchain Community: https://doctoolchain.org/community Testing Guide Overview The AsciiDoc Linter uses Python&#8217;s unittest framework for testing. Tests are organized by rule type and functionality. Running Tests Running All Tests # From project root python run_tests.py # With coverage report coverage run -m unittest discover coverage report Running Specific Tests # Run tests for heading rules python -m unittest tests/rules/test_heading_rules.py # Run a specific test class python -m unittest tests.rules.test_heading_rules.TestHeadingFormatRule # Run a specific test method python -m unittest tests.rules.test_heading_rules.TestHeadingFormatRule.test_valid_format Test Structure Test Organization tests/ ‚îú‚îÄ‚îÄ __init__.py ‚îú‚îÄ‚îÄ rules/ ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îú‚îÄ‚îÄ test_heading_rules.py ‚îÇ ‚îî‚îÄ‚îÄ test_block_rules.py ‚îú‚îÄ‚îÄ test_cli.py ‚îî‚îÄ‚îÄ test_parser.py Test Classes Each rule has its own test class: class TestHeadingFormatRule(unittest.TestCase): def setUp(self): self.rule = HeadingFormatRule() def test_valid_format(self): content = \"\"\" = Valid Heading == Another Valid \"\"\" findings = self.rule.check(content) self.assertEqual(len(findings), 0) Writing Tests Test Guidelines Test both valid and invalid cases Include edge cases Test error messages Test severity levels Test rule configurations Example Test Pattern Arrange: Set up test data Act: Execute the code Assert: Verify results def test_invalid_format(self): # Arrange content = \"=invalid heading\" # Act findings = self.rule.check(content) # Assert self.assertEqual(len(findings), 2) self.assertEqual(findings[0].severity, Severity.ERROR) Test Data Sample Documents Create realistic test documents Cover various scenarios Include complex cases Document test case purpose Test Fixtures Use setUp and tearDown Share common test data Clean up after tests Continuous Integration GitHub Actions name: Tests on: [push, pull_request] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Run Tests run: python run_tests.py Coverage Requirements Aim for 90%+ coverage Cover all code paths Include error conditions Test edge cases Usage Guide Command Line Interface Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Check with specific output format asciidoc-lint --format json document.adoc # Use specific configuration asciidoc-lint --config my-config.yml document.adoc Command Line Options Option Default Description --format console Output format (console, json, html) --config None Path to configuration file --verbose False Enable verbose output --quiet False Suppress non-error output Configuration Configuration File # .asciidoc-lint.yml rules: HEAD001: enabled: true severity: error HEAD002: enabled: true severity: warning Rule Configuration Enable/disable rules Set severity levels Configure rule-specific options Set file patterns Output Formats Console Output document.adoc:15 ERROR: Heading level skipped document.adoc:23 WARNING: Heading should start with uppercase JSON Output { \"findings\": [ { \"rule\": \"HEAD001\", \"severity\": \"error\", \"message\": \"Heading level skipped\", \"line\": 15 } ] } HTML Report Generates a detailed HTML report with: Summary statistics Detailed findings Source context Rule explanations Integration Git Pre-commit Hook #!/bin/sh files=$(git diff --cached --name-only --diff-filter=ACM | grep '.adoc$') if [ -n \"$files\" ]; then asciidoc-lint $files fi CI/CD Integration GitHub Actions Example name: Lint AsciiDoc on: [push, pull_request] jobs: lint: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Lint Documentation run: | pip install asciidoc-linter asciidoc-lint docs/ Best Practices Document Organization Use consistent heading levels Add blank lines around blocks Use proper formatting Include alt text for images Error Resolution Table 2. Common Issues and Solutions Issue Solution Skipped heading level Ensure heading levels increment by one Missing space after = Add space after heading markers Multiple top-level headings Use only one level-1 heading per document Troubleshooting Common Problems Configuration file not found Rule conflicts Performance issues False positives Debug Mode # Enable debug output asciidoc-lint --debug document.adoc # Show rule processing details asciidoc-lint --verbose document.adoc AsciiDoc Linter Rules Heading Rules HEAD001: Heading Hierarchy Ensures proper heading level incrementation (no skipped levels). Description This rule checks that heading levels are not skipped. For example, you cannot go from a level 1 heading (=) directly to a level 3 heading (===) without having a level 2 heading (==) in between. Examples Valid Heading Hierarchy == Document Title (Level 1) === Section (Level 2) ==== Subsection (Level 3) === Another Section (Level 2) Invalid Heading Hierarchy == Document Title (Level 1) ==== Subsection (Level 3) // Error: Skipped Level 2 HEAD002: Heading Format Ensures proper heading format (spacing and capitalization). Description This rule checks two aspects of heading format: 1. There must be a space after the = characters 2. The heading text should start with an uppercase letter Examples Valid Heading Format == Document Title === Section Title ==== Subsection Title Invalid Heading Format =Document Title // Error: No space after = === section title // Warning: Starts with lowercase HEAD003: Multiple Top Level Headings Ensures document has only one top-level heading. Description This rule checks that there is only one level 1 heading (=) in the document. Multiple top-level headings can indicate structural problems or accidentally split documents. Examples Valid Single Top Level == Main Document Title === Section One === Section Two Invalid Multiple Top Level == First Title === Section One == Second Title // Error: Multiple top-level headings Block Rules BLOCK001: Unterminated Blocks Checks for blocks that are not properly terminated. Description This rule ensures that all block delimiters are properly paired. Each opening delimiter must have a matching closing delimiter. Supported Block Types Listing blocks (----) Example blocks (====) Sidebar blocks ( * *) Literal blocks (&#8230;&#8203;.) Quote blocks ( __ ) Table blocks (|===) Comment blocks (////) Passthrough blocks (). Examples Valid Block Termination [source,python] def hello(): print(\"Hello, World!\") .Example Block ==== Some example content ==== Invalid Block Termination [source,python] def hello(): print(\"Hello, World!\") Example 1. Example Block Some example content ==== BLOCK002: Block Spacing Verifies proper spacing around blocks. ===== Description This rule checks that blocks are properly separated from surrounding content with blank lines, improving readability. ===== Examples .Valid Block Spacing [source,asciidoc] Some text before the block. Block content Some text after the block. .Invalid Block Spacing [source,asciidoc] Some text before the block. ---- // Warning: No blank line before block Block content Some text after the block. // Warning: No blank line after block === Whitespace Rules ==== WS001: Whitespace Usage Ensures proper whitespace usage throughout the document. ===== Checks Performed Consecutive Empty Lines : No more than one consecutive empty line List Marker Spacing : Proper space after list markers (*, -, .) Admonition Block Spacing : Blank line before admonition blocks Trailing Whitespace : No trailing spaces at end of lines Tab Usage : No tabs (use spaces instead) Section Title Spacing : Blank lines around section titles ===== Examples Valid Whitespace Usage == Document Title === Section Title * List item 1 * List item 2 NOTE: This is a note. Some text here. Invalid Whitespace Usage == Document Title === Section Title // Missing blank line before *Invalid list item // Missing space after marker NOTE: Invalid note // Missing blank line before Some text here // Trailing spaces Tabbed line // Tab instead of spaces Extra blank line // Too many blank lines === Image Rules ==== IMG001: Image Attributes Verifies image attributes and file references. ===== Description This rule checks: 1. All images have alt text 2. Referenced local images exist 3. Block images have titles 4. Image attributes are properly formatted ===== Examples Valid Image Usage // Inline image with alt text image:icon.png[Icon] // Block image with title and alt text .Figure 1: System Architecture image::diagram.png[Architecture Diagram] // External image with alt text image:https://example.com/img.png[Example Image] Invalid Image Usage // Missing alt text image:icon.png[] // Missing title for block image image::diagram.png[Diagram] // Non-existent local file image::missing.png[Missing Image] === Planned Rules ==== TABLE001: Table Formatting (Planned) Will check table formatting consistency: * Column alignment * Header row presence * Cell content formatting ==== LINK001: Link Verification (Planned) Will verify: * Internal cross-references * External link validity * Anchor definitions ==== FMT001: Format Consistency (Planned) Will check: * Consistent emphasis style * List formatting * Admonition usage "
},

{
    "id": 21,
    "uri": "search.html",
    "menu": "-",
    "title": "search",
    "text": " Search Results "
},

{
    "id": 22,
    "uri": "lunrjsindex.html",
    "menu": "-",
    "title": "null",
    "text": " will be replaced by the index "
},

];
